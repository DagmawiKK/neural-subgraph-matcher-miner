<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
    <title>Interactive Graph Visualizer</title>
    <style>
        :root {
            /* Color Palette - Light Theme */
            --bg-primary: #fafafa;
            --bg-secondary: rgba(255, 255, 255, 0.9);
            --border-light: rgba(0, 0, 0, 0.1);
            --text-primary: #374151;
            --text-secondary: #6b7280;
            
            /* Node Colors */
            --node-default: rgba(59, 130, 246, 0.7);
            --node-anchor: rgba(239, 68, 68, 0.8);
            --node-border: rgba(0, 0, 0, 0.3);
            
            /* Edge Colors */
            --edge-default: rgba(107, 114, 128, 0.6);
            --edge-hover: rgba(59, 130, 246, 0.8);
            
            /* UI Elements */
            --card-bg: rgba(255, 255, 255, 0.95);
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --card-border: rgba(0, 0, 0, 0.1);
            
            /* Grid Colors */
            --grid-minor: rgba(0, 0, 0, 0.03);
            --grid-major: rgba(0, 0, 0, 0.08);
            --grid-axis: rgba(59, 130, 246, 0.15);
            --grid-dots: rgba(0, 0, 0, 0.1);
            --grid-center: rgba(59, 130, 246, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* Full-screen canvas container */
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #graph-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab;
            background-color: var(--bg-primary);
            background-image: 
                radial-gradient(circle at 1px 1px, rgba(0,0,0,0.02) 1px, transparent 0);
            background-size: 20px 20px;
        }

        #graph-canvas:active {
            cursor: grabbing;
        }

        /* Grid background overlay - disabled since we draw grid on canvas */
        #grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none; /* Grid is now drawn on canvas for proper transformation */
        }

        /* Base UI card styling */
        .ui-card {
            position: absolute;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            box-shadow: var(--card-shadow);
            backdrop-filter: blur(10px);
            z-index: 1000;
            padding: 12px;
            color: var(--text-primary);
            font-size: 14px;
        }

        /* Floating UI component positions */
        .top-left {
            top: 20px;
            left: 20px;
        }

        .top-center {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .top-right {
            top: 20px;
            right: 20px;
        }

        .bottom-right-upper {
            bottom: 180px;
            right: 20px;
        }

        .bottom-right-lower {
            bottom: 20px;
            right: 20px;
        }

        /* Title bar styling */
        #title-bar {
            text-align: center;
            font-weight: 600;
            font-size: 16px;
            min-width: 300px;
        }

        #title-bar .subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* Zoom controls styling */
        #zoom-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        #zoom-controls button {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        #zoom-controls button:hover {
            background: var(--bg-primary);
            border-color: var(--text-secondary);
        }

        #zoom-controls button:active {
            transform: scale(0.95);
        }

        /* Legend card styling */
        #legend-card {
            min-width: 220px;
            max-width: 280px;
            max-height: 400px;
            overflow-y: auto;
        }

        #legend-card h3 {
            margin-bottom: 16px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-light);
            padding-bottom: 8px;
        }

        .legend-section {
            margin-bottom: 16px;
        }

        .legend-section:last-child {
            margin-bottom: 0;
        }

        .legend-section h4 {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
            font-size: 12px;
            padding: 2px 0;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid var(--border-light);
            flex-shrink: 0;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .legend-shape {
            width: 18px;
            height: 18px;
            border: 1px solid var(--border-light);
            flex-shrink: 0;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .legend-item span {
            color: var(--text-primary);
            font-weight: 500;
            line-height: 1.2;
        }

        /* Controls card styling */
        #controls-card {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 200px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-group label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--node-default);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .export-buttons {
            display: flex;
            gap: 8px;
        }

        .export-buttons button {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--border-light);
            border-radius: 4px;
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .export-buttons button:hover {
            background: var(--bg-primary);
            border-color: var(--text-secondary);
        }

        /* Context menu styling */
        #context-menu {
            position: absolute;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            box-shadow: var(--card-shadow);
            backdrop-filter: blur(10px);
            z-index: 2000;
            padding: 4px 0;
            min-width: 120px;
        }

        #context-menu.hidden {
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-primary);
            transition: background-color 0.2s ease;
        }

        .context-menu-item:hover {
            background-color: var(--bg-primary);
        }

        /* Isolation effects */
        .node-isolated {
            filter: blur(2px);
            opacity: 0.3;
        }

        .edge-isolated {
            filter: blur(2px);
            opacity: 0.2;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .ui-card {
                padding: 8px;
                font-size: 12px;
            }
            
            .top-left, .top-right {
                top: 10px;
            }
            
            .top-left {
                left: 10px;
            }
            
            .top-right {
                right: 10px;
            }
            
            .bottom-right-upper {
                bottom: 140px;
                right: 10px;
            }
            
            .bottom-right-lower {
                bottom: 10px;
                right: 10px;
            }
            
            #title-bar {
                min-width: 200px;
                font-size: 14px;
            }
            
            #zoom-controls button {
                width: 32px;
                height: 32px;
                font-size: 16px;
            }
            
            #legend-card, #controls-card {
                min-width: 160px;
            }
        }

        @media (max-width: 480px) {
            .ui-card {
                padding: 6px;
                font-size: 11px;
            }
            
            #title-bar {
                min-width: 150px;
                font-size: 12px;
            }
            
            #zoom-controls button {
                width: 28px;
                height: 28px;
                font-size: 14px;
            }
            
            #legend-card, #controls-card {
                min-width: 140px;
            }
        }
    </style>
</head>
<body>
    <!-- Full-screen canvas container -->
    <div id="canvas-container">
        <canvas id="graph-canvas"></canvas>
        <div id="grid-overlay"></div>
    </div>
    
    <!-- Floating UI Components -->
    
    <!-- Title bar at center-top -->
    <div id="title-bar" class="ui-card top-center">
        <div id="graph-title">Graph Visualization</div>
        <div class="subtitle" id="graph-stats">Loading...</div>
    </div>
    
    <!-- Zoom controls in top-right corner -->
    <div id="zoom-controls" class="ui-card top-right">
        <button id="zoom-in" title="Zoom In">+</button>
        <button id="zoom-out" title="Zoom Out">−</button>
        <button id="recenter" title="Recenter">⌂</button>
    </div>
    
    <!-- Legend card in bottom-right area (upper) -->
    <div id="legend-card" class="ui-card bottom-right-upper">
        <h3>Legend</h3>
        <div id="legend-content">
            <!-- Legend items will be populated by JavaScript -->
        </div>
    </div>
    
    <!-- Controls card in bottom-right area (lower) -->
    <div id="controls-card" class="ui-card bottom-right-lower">
        <div class="control-group">
            <label>Show Labels</label>
            <label class="toggle-switch">
                <input type="checkbox" id="label-toggle" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        
        <div class="control-group">
            <label>Export</label>
            <div class="export-buttons">
                <button id="export-pdf">PDF</button>
                <button id="export-svg">PNG</button>
            </div>
        </div>
    </div>
    
    <!-- Context Menu -->
    <div id="context-menu" class="hidden">
        <div class="context-menu-item" id="isolate-node">Isolate</div>
        <div class="context-menu-item" id="copy-label">Copy Label</div>
        <div class="context-menu-item" id="cancel-isolate" style="display: none;">Cancel Isolate</div>
    </div>

    <script>
        // Sample 7-node directed graph data
        const GRAPH_DATA = {
        "metadata": {
                "title": "Directed Graph with Anchors",
                "nodeCount": 11,
                "edgeCount": 10,
                "isDirected": true,
                "density": 0.091
        },
        "nodes": [
                {
                        "id": "enst00000316891",
                        "label": "transcript",
                        "transcript_name": "TRIT1-201",
                        "gene_name": "TRIT1",
                        "anchor": false,
                        "x": 27.65196752359671,
                        "y": 197.0768524739416
                },
                {
                        "id": "enst00000441669",
                        "label": "transcript",
                        "transcript_name": "TRIT1-203",
                        "gene_name": "TRIT1",
                        "anchor": false,
                        "x": 198.15733023744193,
                        "y": 37.6455322302267
                },
                {
                        "id": "q9h3h1-1",
                        "label": "protein",
                        "protein_name": "MOD5",
                        "isoform_name": "1",
                        "anchor": false,
                        "x": -95.0809692854939,
                        "y": -177.28703171738803
                },
                {
                        "id": "enst00000372818",
                        "label": "transcript",
                        "transcript_name": "TRIT1-202",
                        "gene_name": "TRIT1",
                        "anchor": false,
                        "x": -166.60054744627251,
                        "y": 98.79798083873025
                },
                {
                        "id": "enst00000491865",
                        "label": "transcript",
                        "transcript_name": "TRIT1-211",
                        "gene_name": "TRIT1",
                        "anchor": false,
                        "x": 134.0590518547878,
                        "y": 137.61826291770697
                },
                {
                        "id": "q9h3h1-4",
                        "label": "protein",
                        "protein_name": "MOD5",
                        "isoform_name": "4",
                        "anchor": false,
                        "x": -93.3767504466559,
                        "y": 183.95972216092807
                },
                {
                        "id": "q9h3h1-5",
                        "label": "protein",
                        "protein_name": "MOD5",
                        "isoform_name": "5",
                        "anchor": false,
                        "x": 200.0,
                        "y": -83.77624813100846
                },
                {
                        "id": "enst00000465417",
                        "label": "transcript",
                        "transcript_name": "TRIT1-206",
                        "gene_name": "TRIT1",
                        "anchor": false,
                        "x": -151.2725718127031,
                        "y": -93.40322484041486
                },
                {
                        "id": "enst00000467774",
                        "label": "transcript",
                        "transcript_name": "TRIT1-207",
                        "gene_name": "TRIT1",
                        "anchor": false,
                        "x": -166.33749633917537,
                        "y": 4.219155404037533
                },
                {
                        "id": "enst00000462243",
                        "label": "transcript",
                        "transcript_name": "TRIT1-204",
                        "gene_name": "TRIT1",
                        "anchor": false,
                        "x": 18.033079069290444,
                        "y": -188.57476352637613
                },
                {
                        "id": "ensg00000043514",
                        "label": "gene",
                        "gene_name": "TRIT1",
                        "anchor": true,
                        "x": 94.7669066451839,
                        "y": -116.27623781038359
                }
        ],
        "edges": [
                {
                        "label": "translates_to",
                        "weight": 1.0,
                        "source": "enst00000316891",
                        "target": "q9h3h1-1",
                        "directed": true,
                        "direction": "enst00000316891 -> q9h3h1-1",
                },
                {
                        "label": "translates_to",
                        "weight": 1.0,
                        "source": "enst00000441669",
                        "target": "q9h3h1-5",
                        "directed": true,
                        "direction": "enst00000441669 -> q9h3h1-5",
                },
                {
                        "label": "translates_to",
                        "weight": 1.0,
                        "source": "enst00000372818",
                        "target": "q9h3h1-4",
                        "directed": true,
                        "direction": "enst00000372818 -> q9h3h1-4",
                },
                {
                        "label": "transcribed_to",
                        "weight": 1.0,
                        "source": "ensg00000043514",
                        "target": "enst00000316891",
                        "directed": true,
                        "direction": "ensg00000043514 -> enst00000316891",
                },
                {
                        "label": "transcribed_to",
                        "weight": 1.0,
                        "source": "ensg00000043514",
                        "target": "enst00000441669",
                        "directed": true,
                        "direction": "ensg00000043514 -> enst00000441669",
                },
                {
                        "label": "transcribed_to",
                        "weight": 1.0,
                        "source": "ensg00000043514",
                        "target": "enst00000372818",
                        "directed": true,
                        "direction": "ensg00000043514 -> enst00000372818",
                },
                {
                        "label": "transcribed_to",
                        "weight": 1.0,
                        "source": "ensg00000043514",
                        "target": "enst00000491865",
                        "directed": true,
                        "direction": "ensg00000043514 -> enst00000491865",
                },
                {
                        "label": "transcribed_to",
                        "weight": 1.0,
                        "source": "ensg00000043514",
                        "target": "enst00000465417",
                        "directed": true,
                        "direction": "ensg00000043514 -> enst00000465417",
                },
                {
                        "label": "transcribed_to",
                        "weight": 1.0,
                        "source": "ensg00000043514",
                        "target": "enst00000467774",
                        "directed": true,
                        "direction": "ensg00000043514 -> enst00000467774",
                },
                {
                        "label": "transcribed_to",
                        "weight": 1.0,
                        "source": "ensg00000043514",
                        "target": "enst00000462243",
                        "directed": true,
                        "direction": "ensg00000043514 -> enst00000462243",
                }
        ],
        "legend": {
                "nodeTypes": [
                        {
                                "label": "gene",
                                "color": "rgba(59, 130, 246, 0.7)",
                                "description": "gene"
                        },
                        {
                                "label": "transcript",
                                "color": "rgba(34, 197, 94, 0.7)",
                                "description": "transcript"
                        },
                        {
                                "label": "protein",
                                "color": "rgba(245, 101, 101, 0.7)",
                                "description": "Protein"
                        }
                ],
                "edgeTypes": [
                        {
                                "label": "transcribed_to",
                                "color": "rgba(34, 100, 94, 0.7)",
                                "description": "transcribed_to"
                        },
                        {
                                "label": "translates_to",
                                "color": "rgba(245, 190, 101, 0.7)",
                                "description": "translates_to"
                        }
                    ]
                }
            };

        // Dynamic Style Management System
        class StyleManager {
            constructor() {
                this.nodeTypeColors = new Map();
                this.edgeTypeColors = new Map();
                this.discoveredNodeTypes = new Set();
                this.discoveredEdgeTypes = new Set();
                this.colorSeed = 0;
            }
            
            discoverTypes(nodes, edges) {
                // Clear previous discoveries for fresh analysis
                this.discoveredNodeTypes.clear();
                this.discoveredEdgeTypes.clear();
                
                // Discover all unique node types (excluding anchors as they have special handling)
                nodes.forEach(node => {
                    if (node.label && !node.anchor) {
                        this.discoveredNodeTypes.add(node.label);
                    }
                });
                
                // Discover all unique edge types
                edges.forEach(edge => {
                    if (edge.label) {
                        this.discoveredEdgeTypes.add(edge.label);
                    }
                });
                
                // Generate colors for discovered types
                this.generateColorsForTypes();
                
                // Update legend immediately after discovery
                this.updateLegend();
                
                // Validate requirements are met
                this.validateLegendRequirements();
                
                console.log(`Legend updated: ${this.discoveredNodeTypes.size} node types, ${this.discoveredEdgeTypes.size} edge types`);
            }
            
            generateColorsForTypes() {
                // Reset color seed for consistent color generation
                this.colorSeed = 0;
                
                // Generate colors for node types with better distribution
                const sortedNodeTypes = Array.from(this.discoveredNodeTypes).sort();
                sortedNodeTypes.forEach(type => {
                    if (!this.nodeTypeColors.has(type)) {
                        this.nodeTypeColors.set(type, this.generateLightTransparentColor(0.7));
                    }
                });
                
                // Generate colors for edge types with slightly more transparency
                const sortedEdgeTypes = Array.from(this.discoveredEdgeTypes).sort();
                sortedEdgeTypes.forEach(type => {
                    if (!this.edgeTypeColors.has(type)) {
                        this.edgeTypeColors.set(type, this.generateLightTransparentColor(0.6));
                    }
                });
            }
            
            generateLightTransparentColor(alpha = 0.7) {
                // Use golden angle for optimal color distribution
                const hue = (this.colorSeed * 137.508) % 360;
                
                // Ensure good saturation and lightness for readability
                const saturation = 50 + (this.colorSeed * 19) % 25; // 50-75% saturation
                const lightness = 65 + (this.colorSeed * 13) % 20; // 65-85% lightness
                
                this.colorSeed++;
                
                // Convert HSL to RGB
                const rgb = this.hslToRgb(hue / 360, saturation / 100, lightness / 100);
                return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
            }
            
            hslToRgb(h, s, l) {
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }
            
            getNodeColor(type) {
                if (!type) type = 'default';
                
                if (!this.nodeTypeColors.has(type)) {
                    this.nodeTypeColors.set(type, this.generateLightTransparentColor(0.7));
                    this.discoveredNodeTypes.add(type);
                    this.updateLegend();
                }
                
                return this.nodeTypeColors.get(type);
            }
            
            getEdgeColor(type) {
                if (!type) type = 'default';
                
                if (!this.edgeTypeColors.has(type)) {
                    this.edgeTypeColors.set(type, this.generateLightTransparentColor(0.6));
                    this.discoveredEdgeTypes.add(type);
                    this.updateLegend();
                }
                
                return this.edgeTypeColors.get(type);
            }
            
            // Method to force legend refresh - useful for external calls
            refreshLegend() {
                this.updateLegend();
            }
            
            // Validate that legend meets all requirements
            validateLegendRequirements() {
                const legendContent = document.getElementById('legend-content');
                const results = {
                    requirement_5_1: !!legendContent, // Legend card exists
                    requirement_5_2: this.discoveredNodeTypes.size > 0, // Node types shown
                    requirement_5_3: this.discoveredEdgeTypes.size > 0, // Edge types shown
                    requirement_5_4: legendContent.innerHTML.includes('Anchor Nodes'), // Anchor indication
                    proper_spacing: legendContent.querySelectorAll('.legend-section').length > 0,
                    color_mapping: this.nodeTypeColors.size > 0 || this.edgeTypeColors.size > 0
                };
                
                console.log('Legend Requirements Validation:', results);
                return results;
            }
            
            updateLegend() {
                const legendContent = document.getElementById('legend-content');
                if (!legendContent) return;
                
                // Clear existing content
                legendContent.innerHTML = '';
                
                // Create legend sections with proper spacing and readability
                this.createNodeTypesLegend(legendContent);
                this.createEdgeTypesLegend(legendContent);
                this.createAnchorNodesLegend(legendContent);
            }
            
            createNodeTypesLegend(legendContent) {
                if (this.discoveredNodeTypes.size === 0) return;
                
                const nodeSection = document.createElement('div');
                nodeSection.className = 'legend-section';
                
                const header = document.createElement('h4');
                header.textContent = 'Node Types';
                nodeSection.appendChild(header);
                
                // Sort node types alphabetically for consistent display
                const sortedNodeTypes = Array.from(this.discoveredNodeTypes).sort();
                
                sortedNodeTypes.forEach(type => {
                    const color = this.nodeTypeColors.get(type);
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = color;
                    
                    const label = document.createElement('span');
                    label.textContent = type;
                    
                    item.appendChild(colorBox);
                    item.appendChild(label);
                    nodeSection.appendChild(item);
                });
                
                legendContent.appendChild(nodeSection);
            }
            
            createEdgeTypesLegend(legendContent) {
                if (this.discoveredEdgeTypes.size === 0) return;
                
                const edgeSection = document.createElement('div');
                edgeSection.className = 'legend-section';
                
                const header = document.createElement('h4');
                header.textContent = 'Edge Types';
                edgeSection.appendChild(header);
                
                // Sort edge types alphabetically for consistent display
                const sortedEdgeTypes = Array.from(this.discoveredEdgeTypes).sort();
                
                sortedEdgeTypes.forEach(type => {
                    const color = this.edgeTypeColors.get(type);
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = color;
                    
                    const label = document.createElement('span');
                    label.textContent = type;
                    
                    item.appendChild(colorBox);
                    item.appendChild(label);
                    edgeSection.appendChild(item);
                });
                
                legendContent.appendChild(edgeSection);
            }
            
            createAnchorNodesLegend(legendContent) {
                // Always show anchor nodes section as per requirement 5.4
                const anchorSection = document.createElement('div');
                anchorSection.className = 'legend-section';
                
                const header = document.createElement('h4');
                header.textContent = 'Special Nodes';
                anchorSection.appendChild(header);
                
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-shape';
                colorBox.style.backgroundColor = 'rgba(239, 68, 68, 0.8)';
                colorBox.style.borderRadius = '2px'; // Make it more square-like
                
                const label = document.createElement('span');
                label.textContent = 'Anchor Nodes';
                
                item.appendChild(colorBox);
                item.appendChild(label);
                anchorSection.appendChild(item);
                
                legendContent.appendChild(anchorSection);
            }
            
            getTypeStatistics() {
                return {
                    nodeTypes: Array.from(this.discoveredNodeTypes),
                    edgeTypes: Array.from(this.discoveredEdgeTypes),
                    nodeTypeCount: this.discoveredNodeTypes.size,
                    edgeTypeCount: this.discoveredEdgeTypes.size
                };
            }
        }

        class GraphLayoutEngine {
            constructor() {
                this.minDistance = 460; // Minimum distance between nodes
                this.iterations = 100; // Layout algorithm iterations
                this.repulsionStrength = 1000;
                this.attractionStrength = 0.1;
                this.damping = 0.9;
            }
            
            applyForceDirectedLayout(nodes, edges) {
                // Create node lookup
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                    // Initialize velocity if not present
                    if (!node.vx) node.vx = 0;
                    if (!node.vy) node.vy = 0;
                });
                
                // Apply force-directed layout algorithm
                for (let iter = 0; iter < this.iterations; iter++) {
                    // Reset forces
                    nodes.forEach(node => {
                        node.fx = 0;
                        node.fy = 0;
                    });
                    
                    // Apply repulsion forces between all nodes
                    for (let i = 0; i < nodes.length; i++) {
                        for (let j = i + 1; j < nodes.length; j++) {
                            this.applyRepulsion(nodes[i], nodes[j]);
                        }
                    }
                    
                    // Apply attraction forces along edges
                    edges.forEach(edge => {
                        const source = nodeMap[edge.source];
                        const target = nodeMap[edge.target];
                        if (source && target) {
                            this.applyAttraction(source, target);
                        }
                    });
                    
                    // Update positions
                    nodes.forEach(node => {
                        if (!node.anchor) { // Don't move anchor nodes
                            node.vx = (node.vx + node.fx) * this.damping;
                            node.vy = (node.vy + node.fy) * this.damping;
                            node.x += node.vx;
                            node.y += node.vy;
                        }
                    });
                }
                
                // Clean up temporary properties
                nodes.forEach(node => {
                    delete node.fx;
                    delete node.fy;
                    delete node.vx;
                    delete node.vy;
                });
            }
            
            applyRepulsion(node1, node2) {
                const dx = node2.x - node1.x;
                const dy = node2.y - node1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0 && distance < this.minDistance * 3) {
                    const force = this.repulsionStrength / (distance * distance);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;
                    
                    node1.fx -= fx;
                    node1.fy -= fy;
                    node2.fx += fx;
                    node2.fy += fy;
                }
            }
            
            applyAttraction(source, target) {
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > this.minDistance) {
                    const force = this.attractionStrength * (distance - this.minDistance);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;
                    
                    source.fx += fx;
                    source.fy += fy;
                    target.fx -= fx;
                    target.fy -= fy;
                }
            }
            
            generateInitialLayout(nodes, edges) {
                // Generate initial positions if not provided
                const radius = Math.max(100, nodes.length * 15);
                
                nodes.forEach((node, index) => {
                    if (node.x === undefined || node.y === undefined) {
                        if (node.anchor) {
                            // Place anchor nodes at origin or specific positions
                            node.x = 0;
                            node.y = 0;
                        } else {
                            // Distribute other nodes in a circle
                            const angle = (index * 2 * Math.PI) / nodes.length;
                            node.x = Math.cos(angle) * radius;
                            node.y = Math.sin(angle) * radius;
                        }
                    }
                });
                
                // Apply force-directed layout to improve positioning
                this.applyForceDirectedLayout(nodes, edges);
            }
            // Add this to your GraphLayoutEngine class

            generateConcentricLayout(nodes, edges, minLayerDistance = 380) {
                // 1. Build adjacency and degree maps
                const nodeMap = {};
                const degreeMap = {};
                const neighborsMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                    degreeMap[node.id] = 0;
                    neighborsMap[node.id] = [];
                });
                edges.forEach(edge => {
                    if (nodeMap[edge.source] && nodeMap[edge.target]) {
                        degreeMap[edge.source]++;
                        degreeMap[edge.target]++;
                        neighborsMap[edge.source].push(edge.target);
                        if (!edge.directed) {
                            neighborsMap[edge.target].push(edge.source);
                        }
                    }
                });

                // 2. Find highest degree node
                let centerNodeId = nodes[0].id;
                let maxDegree = -1;
                for (const id in degreeMap) {
                    if (degreeMap[id] > maxDegree) {
                        maxDegree = degreeMap[id];
                        centerNodeId = id;
                    }
                }

                // 3. BFS to assign layers and parents
                const distances = {};
                const allParents = {};
                const primaryParent = {};
                const visited = new Set();
                const queue = [];
                distances[centerNodeId] = 0;
                allParents[centerNodeId] = [];
                primaryParent[centerNodeId] = null;
                queue.push(centerNodeId);
                visited.add(centerNodeId);

                while (queue.length > 0) {
                    const nodeId = queue.shift();
                    const dist = distances[nodeId];
                    const neighbors = neighborsMap[nodeId] || [];
                    neighbors.forEach(neighborId => {
                        if (!visited.has(neighborId)) {
                            distances[neighborId] = dist + 1;
                            allParents[neighborId] = [nodeId];
                            primaryParent[neighborId] = nodeId;
                            queue.push(neighborId);
                            visited.add(neighborId);
                        } else if (distances[neighborId] === dist + 1) {
                            if (!allParents[neighborId]) allParents[neighborId] = [];
                            allParents[neighborId].push(nodeId);
                        }
                    });
                }

                // 4. Group nodes by layer
                const layers = {};
                for (const nodeId in distances) {
                    const d = distances[nodeId];
                    if (!layers[d]) layers[d] = [];
                    layers[d].push(nodeId);
                }

                // 5. Layout parameters
                const numNodes = nodes.length;
                let baseRadius;
                const radiusIncrement = Math.max(minLayerDistance, numNodes <= 8 ? 140 : 90);
                if (numNodes <= 5) {
                    baseRadius = 280;
                } else if (numNodes <= 10) {
                    baseRadius = 350;
                } else if (numNodes <= 15) {
                    baseRadius = 350;
                } else if (numNodes <= 20) {
                    baseRadius = 560;
                } else {
                    baseRadius = 640;
                }

                // 6. Assign positions
                const pos = {};
                pos[centerNodeId] = { x: 0, y: 0 };

                // Layer 1: arrange in a circle
                if (layers[1]) {
                    const layer1 = layers[1];
                    layer1.sort((a, b) => degreeMap[b] - degreeMap[a] || a.localeCompare(b));
                    const n = layer1.length;
                    for (let i = 0; i < n; i++) {
                        const angle = 2 * Math.PI * i / n;
                        pos[layer1[i]] = {
                            x: baseRadius * Math.cos(angle),
                            y: baseRadius * Math.sin(angle)
                        };
                    }
                }

                // Layers 2+
                const maxLayer = Math.max(...Object.keys(layers).map(Number));
                for (let layer = 2; layer <= maxLayer; layer++) {
                    if (!layers[layer]) continue;
                    const nodesInLayer = layers[layer];
                    nodesInLayer.forEach(nodeId => {
                        const parents = allParents[nodeId] || [];
                        if (parents.length === 1) {
                            // Single parent: radial from center through parent
                            const parentPos = pos[parents[0]];
                            const norm = Math.sqrt(parentPos.x * parentPos.x + parentPos.y * parentPos.y);
                            const radialDir = norm > 0 ? { x: parentPos.x / norm, y: parentPos.y / norm } : { x: 1, y: 0 };
                            let layerDist = baseRadius + (layer - 1) * radiusIncrement;
                            // Sibling spread
                            const siblings = nodesInLayer.filter(nid => (allParents[nid] || []).length === 1 && allParents[nid][0] === parents[0]);
                            let offset = 0;
                            if (siblings.length > 1) {
                                const idx = siblings.indexOf(nodeId);
                                const spread = Math.min(80, layerDist * 0.3);
                                const perpDir = { x: -radialDir.y, y: radialDir.x };
                                offset = (idx - (siblings.length - 1) / 2) * (spread / Math.max(1, siblings.length - 1));
                                pos[nodeId] = {
                                    x: radialDir.x * layerDist + perpDir.x * offset,
                                    y: radialDir.y * layerDist + perpDir.y * offset
                                };
                            } else {
                                pos[nodeId] = {
                                    x: radialDir.x * layerDist,
                                    y: radialDir.y * layerDist
                                };
                            }
                        } else if (parents.length > 1) {
                            // Multiple parents: centroid, then move outward
                            let centroid = { x: 0, y: 0 };
                            let count = 0;
                            parents.forEach(pid => {
                                if (pos[pid]) {
                                    centroid.x += pos[pid].x;
                                    centroid.y += pos[pid].y;
                                    count++;
                                }
                            });
                            if (count > 0) {
                                centroid.x /= count;
                                centroid.y /= count;
                            }
                            const norm = Math.sqrt(centroid.x * centroid.x + centroid.y * centroid.y);
                            const direction = norm > 0 ? { x: centroid.x / norm, y: centroid.y / norm } : { x: 1, y: 0 };
                            let layerDist = baseRadius + (layer - 1) * radiusIncrement;
                            // For diamond patterns, bring closer
                            if (parents.length === 2 && count === 2) {
                                // Check if parents are far apart
                                const p1 = pos[parents[0]], p2 = pos[parents[1]];
                                const n1 = Math.sqrt(p1.x * p1.x + p1.y * p1.y);
                                const n2 = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
                                if (n1 > 0 && n2 > 0) {
                                    const dir1 = { x: p1.x / n1, y: p1.y / n1 };
                                    const dir2 = { x: p2.x / n2, y: p2.y / n2 };
                                    const dot = dir1.x * dir2.x + dir1.y * dir2.y;
                                    const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
                                    if (angle > Math.PI / 2) {
                                        layerDist *= 0.8;
                                    }
                                }
                            }
                            pos[nodeId] = {
                                x: direction.x * layerDist,
                                y: direction.y * layerDist
                            };
                        }
                    });
                }

                // 7. Assign positions to node objects
                nodes.forEach(node => {
                    if (pos[node.id]) {
                        node.x = pos[node.id].x;
                        node.y = pos[node.id].y;
                    }
                });
            }   
        }